1. 基础概念
1.1 数据类型与变量
● 题目示例：
  ○ 请说明 JavaScript 的原始（基本）数据类型有哪些？它们是如何存储的？
  ○ 什么是动态类型语言？JavaScript 中变量的类型转换机制是怎样的？
● 考察点：
  ○ 原始类型：Number、String、Boolean、Null、Undefined、Symbol（ES6）和 BigInt（ES2020）。
  ○ 对象类型：Object、Array、Function 等。
  ○ 动态类型语言特点，隐式类型转换及其坑（如 == 与 === 区别）。
1.2 运算符与比较
● 题目示例：
  ○ == 与 === 的区别是什么？
  ○ 如何实现深拷贝和浅拷贝？请举例说明常见方法和注意点。
● 考察点：
  ○ == 会进行类型转换，=== 是全等比较。
  ○ 浅拷贝方法：Object.assign()、展开运算符；深拷贝方法：递归、JSON.parse(JSON.stringify())（注意特殊数据如函数、Date 等）。

2. 执行上下文、作用域与闭包
2.1 执行上下文与作用域链
● 题目示例：
  ○ 请说明 JavaScript 的执行上下文是什么？如何形成作用域链？
  ○ 什么是词法作用域，如何与动态作用域区分？
● 考察点：
  ○ 执行上下文（Global、Function、Eval），创建和销毁顺序。
  ○ 作用域链的形成：每个执行上下文有自己的变量对象，通过 LexicalEnvironment 链连接到上级上下文。
  ○ 静态（词法）作用域：函数的作用域在定义时就已经确定。
2.2 闭包
● 题目示例：
  ○ 什么是闭包？请给出一个闭包的例子，并说明它的实际应用场景。
  ○ 闭包会带来哪些内存问题？如何避免内存泄漏？
● 考察点：
  ○ 闭包是函数与其词法环境的组合，能访问函数外部变量。
  ○ 应用场景：数据私有化、模块化、缓存/记忆函数结果等。
  ○ 内存泄漏问题：引用未释放的变量、循环引用等；建议及时解除引用、使用局部变量。

3. 异步编程与事件循环
3.1 异步编程
● 题目示例：
  ○ 请分别解释回调函数、Promise 和 async/await 的工作原理和优缺点。
  ○ 如何解决回调地狱问题？请举例说明。
● 考察点：
  ○ 回调函数：传统异步处理方式，容易产生回调嵌套。
  ○ Promise：链式调用，便于错误捕获与流程控制，缺点是有时链太长仍难调试。
  ○ async/await：语法糖，基于 Promise，使异步代码结构更像同步代码，注意 try/catch 异常处理。
3.2 事件循环与任务队列
● 题目示例：
  ○ 请描述浏览器中的事件循环（Event Loop）机制和宏任务（Macro Tasks）与微任务（Micro Tasks）的执行顺序。
  ○ setTimeout、Promise.then、MutationObserver 的执行顺序是什么？
● 考察点：
  ○ 浏览器采用单线程模型，通过事件循环调度任务执行。
  ○ 执行顺序：宏任务队列中的任务先执行，每执行一个宏任务后，会清空微任务队列。
  ○ 常见案例：setTimeout（宏任务）、Promise.then（微任务）、MutationObserver（微任务）等。

4. 原型与继承
4.1 原型链与继承
● 题目示例：
  ○ 请解释 JavaScript 的原型链是如何工作的，以及如何实现原型继承？
  ○ 如何实现一个深度继承？请简述 ES5 和 ES6 的继承方式的区别。
● 考察点：
  ○ 任何对象都有一个内部属性 [[Prototype]]（proto），对象查找属性时会沿原型链向上查找。
  ○ ES5 中可使用构造函数+原型链、Object.create()；ES6 使用 class 语法，继承关键字 extends，super 调用父类构造器。
  ○ 区分原型式继承与组合式继承中的缺陷以及如何避免。
4.2 call、apply、bind
● 题目示例：
  ○ 请分别说明 call、apply 和 bind 的原理和区别，并手写一个 bind 函数实现。
● 考察点：
  ○ call 和 apply 都能改变函数内部的 this 指向，但参数传递的方式不同（apply 传数组，call 传参数列表）；bind 返回一个新的函数，绑定新的 this 值。

5. ES6+ 与新特性
5.1 新增语法和特性
● 题目示例：
  ○ 请说出 ES6 新增的变量声明方式及它们的区别（var、let、const）。
  ○ 请解释箭头函数与普通函数在 this 绑定上的区别。
● 考察点：
  ○ let/const 块作用域，变量提升问题；const 不可重新赋值但对对象属性可变。
  ○ 箭头函数没有自己的 this，继承外部函数的 this；普通函数的 this 动态绑定。
5.2 其他新特性
● 题目示例：
  ○ 请解释 Symbol 的用途以及如何利用 Symbol 来避免对象属性冲突？
  ○ Generator 函数的原理是什么？请简述其应用场景。
  ○ 请介绍 Promise.all、Promise.race 的原理。
● 考察点：
  ○ Symbol 用于生成全局唯一的标识符；Generator 用于生成迭代器，可以暂停和恢复执行。
  ○ Promise.all 接受多个 Promise，当所有 Promise 都 resolve 后返回；race 返回第一个完成的 Promise。

6. 模块化与前端工程化
6.1 模块化方案
● 题目示例：
  ○ 请比较 CommonJS、AMD 和 ES6 Modules 的区别，前端工程中如何进行模块化开发？
  ○ 请解释 Tree Shaking 的原理。
● 考察点：
  ○ CommonJS 主要用于 Node.js，同步加载；AMD 适合浏览器异步加载；ES6 模块静态加载，具备编译时优化能力。
  ○ Tree Shaking：通过静态分析消除未使用代码，提高打包体积的优化技术。
6.2 前端构建工具
● 题目示例：
  ○ 请介绍一下 Webpack 的工作原理，以及如何提高打包性能。
● 考察点：
  ○ 模块打包、loader 和 plugin 的概念，代码分割、缓存、懒加载等性能优化手段。

7. 内存管理与性能优化
7.1 内存泄漏与垃圾回收
● 题目示例：
  ○ 请说明 JavaScript 的垃圾回收机制有哪些？常见的内存泄漏场景有哪些？
  ○ 如何避免闭包带来的内存泄漏？
● 考察点：
  ○ 垃圾回收主要采用标记清除和引用计数策略；常见泄漏类型：意外全局变量、定时器未清除、DOM 引用未断开、闭包滥用等。
7.2 性能调优
● 题目示例：
  ○ 如何减少重排（Reflow）和重绘（Repaint）的次数？
  ○ 如何利用 Chrome DevTools 分析和解决性能问题？
● 考察点：
  ○ 优化 DOM 操作：批量修改、减少频繁操作页面布局；利用 CSS3 动画触发 GPU 加速。
  ○ 使用 Chrome Performance 面板，分析 Critical Rendering Path 以及任务队列情况。

8. 其他常见问题
● 题目示例：
  ○ 请解释 Event Delegation（事件委托）的原理及优缺点。
  ○ 请说说 Microtask（微任务）与 Macrotask（宏任务）的区别和执行顺序。
  ○ 什么是 IIFE（立即调用的函数表达式），它解决了哪些问题？
  ○ 如何实现一个节流（throttle）和防抖（debounce）函数？
● 考察点：
  ○ 事件委托利用事件冒泡机制，减少绑定事件数量；解释微任务/宏任务的队列，常见任务执行顺序。
  ○ IIFE 用来避免全局作用域污染，创建私有变量。
  ○ 节流与防抖用于优化频繁触发事件（如滚动、窗口调整大小）的性能问题。
三、手写题与代码实现
1. 实现 new 操作符的功能
  ○ 创建新对象、绑定原型、执行构造函数并返回对象。CSDN博客
2. 实现防抖与节流函数
  ○ 防抖：延迟函数执行，适用于输入框搜索等场景。
  ○ 节流：限制函数执行频率，适用于滚动监听等场景。
3. 实现深拷贝函数
  ○ 处理对象、数组、循环引用等情况。
4. 实现 call、apply、bind 方法
  ○ 模拟函数的上下文绑定与参数传递。
5. 实现 Promise.all 与 Promise.race
  ○ 处理多个异步操作的并发控制。
四、性能优化与调试技巧
1. 加载优化
  ○ 懒加载与预加载的实现方式。
  ○ 使用 CDN、压缩资源文件等手段。GitHub
2. 渲染优化
  ○ 虚拟 DOM 与 diff 算法的原理。
  ○ 避免不必要的组件重渲染。
3. 内存优化
  ○ 及时清除不再使用的引用。
  ○ 使用 Chrome DevTools 进行内存泄漏检测。