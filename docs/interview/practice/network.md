一、前端安全漏洞与防护
1. XSS（跨站脚本攻击）
● 题目示例：
  ○ 请简述 XSS 攻击的原理，并分别说明存储型、反射型、以及 DOM 型 XSS 的区别。
  ○ 如何防范 XSS 攻击？请列举输入验证、输出编码和 CSP 的具体作用。
● 考察重点：
  ○ 理解 XSS 的攻击流程（攻击者如何注入恶意脚本；用户浏览时脚本被执行）。
  ○ 防护措施：在前端使用安全框架（如 Vue/React 默认不使用 innerHTML）、避免使用 v-html／dangerouslySetInnerHTML、严格进行输出转义、配置 Content Security Policy (CSP)。
2. CSRF（跨站请求伪造）
● 题目示例：
  ○ 请解释 CSRF 攻击的原理，并说明如何利用 CSRF Token 防范此类攻击。
  ○ 如何通过设置 Cookie 的 SameSite 属性来防范 CSRF 攻击？
● 考察重点：
  ○ CSRF 攻击是利用用户已经登录后的认证信息，通过伪造请求执行操作。
  ○ 防御措施：服务器验证 Referer、在表单中附加 CSRF Token、双重Cookie验证。
3. 点击劫持
● 题目示例：
  ○ 什么是点击劫持？如何通过 X-Frame-Options 防范点击劫持攻击？
● 考察重点：
  ○ 利用 iframe 嵌入恶意页面，诱导用户点击。
  ○ 防护措施：设置 HTTP 响应头 X-Frame-Options（如 DENY 或 SAMEORIGIN）；同时可以通过 CSP 限制 iframe 来源。
4. HTTPS 与中间人攻击（MITM）
● 题目示例：
  ○ HTTPS 如何防范中间人攻击？TLS 握手流程中如何验证服务器的真实性？
  ○ 请解释什么是 HSTS，它如何增强网站的安全性？
● 考察重点：
  ○ HTTPS 及数字证书在防范中间人攻击中的作用；了解 TLS 握手、证书验证等基本流程。
  ○ HSTS（HTTP Strict Transport Security）能够强制浏览器仅使用 HTTPS 与服务器通信。
5. 其他前端安全问题
● 题目示例：
  ○ 介绍前端常见的网络安全问题，如文件上传漏洞、目录遍历漏洞、以及 JSON 劫持，并讨论防护措施。
  ○ 请说明什么是 SQL 注入攻击，以及为什么它更多是后端问题。但前端如何配合后端防止这类漏洞？
● 考察重点：
  ○ 前端虽然不是攻击的主要目标，但在数据输入和展示上需要严格过滤和验证，以减少安全风险。
  ○ 掌握常见漏洞的防范方法，例如对文件上传严格校验、对 URL 参数进行转义等。

二、网络安全与前端性能
6. 浏览器同源策略与跨域资源共享（CORS）
● 题目示例：
  ○ 请解释同源策略的原理，以及如何通过 CORS 实现跨域资源共享。
  ○ 前端在使用 AJAX 请求跨域数据时如何配置 CORS，并说明 Access-Control-Allow-Origin 等响应头的作用。
● 考察重点：
  ○ 理解同源策略的安全意义；
  ○ 掌握配置 CORS 的基本原理，认识到 CORS 中的预检请求、凭证传递等细节。
7. 浏览器加载性能与安全
● 题目示例：
  ○ 浏览器加载网页时的关键渲染路径是什么？请说明如何通过减少阻塞资源的加载来优化网页性能，同时保证安全（如防止第三方脚本注入）。
  ○ 如何预防第三方库中潜在的安全漏洞？例如如何验证引入库的完整性？
● 考察重点：
  ○ 了解浏览器渲染流程，并结合安全措施，如使用 Subresource Integrity (SRI) 来验证第三方资源的完整性。

三、内网安全与等保测评相关
8. 内网安全问题
● 题目示例：
  ○ 请解释内网安全中 IDS 与 IPS 的区别，如何通过这些系统提升内网安全性？
  ○ 简述内网安全监控和漏洞管理的主要方法。
● 考察重点：
  ○ 了解内网安全监控、防火墙、IDS/IPS 的基本原理以及其在前端服务中的应用。
9. 等保测评
● 题目示例：
  ○ 什么是等保测评？其主要目标和评估内容包括哪些方面？
  ○ 在前端项目中，如何配合实现等保测评中的网络安全管理和监控要求？
● 考察重点：
  ○ 认识国家对网络安全等级保护的要求和前端在其中的角色（如前端数据传输加密、防范XSS/CSRF等）。

四、其他进阶与综合性问题
10. 其他攻击手法及防御
● 题目示例：
  ○ 解释什么是 DNS 劫持和网络劫持，前端层面应如何应对？
  ○ 什么是 JSON 劫持及其风险，前端如何防范？
  ○ 描述暴力破解攻击，并说明前端如何在用户体验与安全性间找到平衡。
● 考察重点：
  ○ 综合理解网络安全体系中各种攻击手法，认识到前端不仅要防范脚本注入，还要关注数据传输与用户认证等方面的安全。


网络知识：
1. OSI 七层模型和 TCP/IP 四层模型的分层和含义
OSI 七层模型：
物理层：负责传输原始的比特流，如电气信号、光信号等。
数据链路层：确保物理层传输的数据无误，通过帧的方式传输数据。
网络层：负责数据包从源到目的地的传输和路由选择。
传输层：提供端到端的数据传输服务，主要协议有 TCP（可靠）和 UDP（不可靠）。
会话层：管理和控制两个通信系统之间的会话连接。
表示层：确保数据能够被接收系统理解，如数据格式转换、加密解密等。
应用层：为应用软件提供网络服务，如 HTTP、FTP、SMTP 等。
TCP/IP 四层模型：
链路层：对应 OSI 模型的物理层和数据链路层，负责在物理媒介上传输数据帧。
网络层：对应 OSI 的网络层，主要协议是 IP，负责数据包的路由和传输。
传输层：与 OSI 模型的传输层相对应，提供应用进程间的通信，主要协议有 TCP 和 UDP。
应用层：整合了 OSI 模型的会话层、表示层和应用层，负责处理特定的应用程序细节。

2.TCP 协议怎么保证可靠的，UDP 为什么不可靠？
TCP 通过 连接导向、数据校验、拥塞控制 等机制确保数据的完整性和顺序，以及在网络条件变化时的适应性。这些特性使得 TCP 在数据传输中更加可靠，但同时也增加了协议的复杂性和传输延迟。
UDP 设计为简单和快速（无连接、无拥塞控制、 单播、多播、广播：），牺牲了数据的可靠性以换取效率。它适用于那些可以容忍一定数据丢失，但对实时性要求高的应用，如视频会议、在线游戏和 VoIP（网络电话）。

3. 三次握手和四次挥手过程：
三次握手的过程:
客户端发送 SYN 包：客户端选择一个初始序列号 x，发送 SYN 包给服务器（SYN=1, seq=x）。
服务器响应 SYN-ACK 包：服务器收到 SYN 包后，发送一个 SYN-ACK 包作为响应（SYN=1, ACK=1, seq=y, ack=x+1）。
客户端发送 ACK 包：客户端收到 SYN-ACK 包后，发送 ACK 包确认连接建立（ACK=1, seq=x+1, ack=y+1）。
四次挥手过程，因为 TCP 连接是全双工的,所以每个方向的关闭都需要单独的步骤
主动方发送 FIN 包：主动关闭方发送 FIN 包，请求关闭连接（FIN=1, seq=u）。
被动方响应 ACK 包：被动关闭方收到 FIN 包后，发送 ACK 包作为确认（ACK=1, seq=v, ack=u+1）。
被动方发送 FIN 包：被动关闭方准备关闭连接时，发送 FIN 包（FIN=1, seq=w）。
主动方响应 ACK 包：主动关闭方收到 FIN 包后，发送最后的 ACK 包来关闭连接（ACK=1, seq=u+1, ack=w+1）。
4. TCP 如何保证有效传输及拥塞控制原理。
1.数据校验：通过序列号和校验和确保数据的完整性和正确性。
2.数据重传：如果接收方检测到丢包或损坏的数据，发送方会重传丢失的数据。
3.流量控制：通过滑动窗口机制来控制发送速率，以适应接收方的处理能力。
4.拥塞控制：通过调整发送速率来避免网络拥塞。

拥塞控制的原理涉及几个关键算法：
1.慢启动：开始发送时，TCP 以较低的速率发送数据，并逐渐增加发送窗口大小，直到达到一个阈值或发生丢包。
2.拥塞避免：在达到阈值后，TCP 进入拥塞避免阶段，窗口大小增长速度变慢。
3.快重传：如果发送方收到三个相同的 ACK（对同一个数据包的确认），即使没有达到超时时间，也会触发重传。
4.快恢复：与快重传配合使用，减少窗口大小但不会像慢启动那样大幅度减少，而是稍微减少窗口大小后进入拥塞避免阶段。
10. TCP粘包是怎么回事，如何处理?

5.你对 TCP 滑动窗口有了解嘛？
TCP 滑动窗口是一种流量控制机制，用于确保接收方能够处理发送方发送的数据量, 滑动窗口机制允许 TCP 在不超负荷的情况下高效地传输数据，同时确保数据的顺序和完整性,以下是滑动窗口的基本概念：
1.窗口大小：表示接收方当前能够接收的最大字节数。窗口大小可以动态调整，以适应接收方的处理能力。
2.已发送但未确认的数据：发送方维护一个缓冲区，存放已发送但尚未收到确认的数据。这些数据的字节范围称为"已发送窗口"。
3.接收窗口：接收方维护一个缓冲区，存放已接收但尚未被应用程序读取的数据。接收窗口的大小由接收方的缓冲区大小和当前处理能力决定。
4.序列号：每个 TCP 段都有一个序列号，表示该段数据在发送方数据流中的位置。
5.确认应答：接收方发送的 TCP 段包含一个确认号，它是期待接收的下一个字节的序列号。
6.窗口滑动：当接收方处理了一部分数据后，它会发送一个更新的窗口大小给发送方。发送方根据这个新的窗口大小来发送更多的数据。
7、流量控制：如果接收方的窗口大小变为 0，发送方必须停止发送数据，直到接收方再次发送一个非零窗口大小的确认。
6. HTTP 状态码有哪些？请列举几个常见的状态码及其含义。
200 OK：请求成功，服务器已正常处理请求。
301 Moved Permanently：永久重定向，资源的 URL 已永久更改。
302 Found：临时重定向，资源的 URL 已临时更改。
304 Not Modified：未修改，请求的资源未发生变化，可以使用缓存的版本。
400 Bad Request：客户端请求有语法错误，服务器无法理解。
401 Unauthorized：请求需要用户的身份认证。
403 Forbidden：服务器理解请求但拒绝执行，可能是权限问题。
404 Not Found：服务器上未找到请求的资源。
500 Internal Server Error：服务器内部错误，无法完成请求。
502 Bad Gateway：作为网关或代理的服务器从上游服务器收到无效响应。
503 Service Unavailable：服务器目前无法使用，可能是过载或停机维护。
504 Gateway Timeout：作为网关或代理的服务器未及时从上游服务器接收请求。


7. 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？
1.发送心跳包：定期发送小的数据包，以保持连接活跃。心跳包可以是一个空的数据包或者特定的心跳消息。

2.使用 HTTP 持久连接（HTTP Persistent Connections）：
● 在 HTTP/1.1 中，默认开启持久连接，使用Connection: keep-alive头部。
● 持久连接允许多个请求和响应在同一个 TCP 连接上复用，减少了连接建立和断开的开销。
3.使用长轮询（Long Polling）：
这是一种用于实现实时推送的技术，客户端发送请求后，服务器保持请求打开，直到有数据可发送。
4.使用 WebSocket：
WebSocket 提供了全双工通信通道，可以在客户端和服务器之间建立持久的连接，并允许实时数据交换。

8.解释下 WebSocket ，它们在现代 Web 应用中的作用,或者(比较 WebSockets 和 HTTP 长轮询在实现实时通信时的优缺点)
WebSocket 是一种网络通信协议，提供了在单个 TCP 连接上进行全双工通信的能力。这意味着客户端和服务器可以同时发送和接收数据，实现实时双向交互：
1.全双工通信：WebSocket 允许数据在客户端和服务器之间双向流动，无需客户端轮询或多次请求。
2.持久连接：与 HTTP 请求-响应模式不同，WebSocket 建立连接后，该连接可以保持开放状态，用于传输任意数量的消息。
3.低延迟：由于避免了 HTTP 连接的重复建立和关闭，WebSocket 可以减少通信延迟，适用于需要快速响应的应用。
4.减少开销：WebSocket 数据传输没有 HTTP 头部的开销，使得数据传输更高效。


9. 什么是服务端推送技术（Server-Sent Events 或 WebSockets）？

1.Server-Sent Events (SSE)：
● SSE 是一种允许服务器向客户端发送新数据的技术，通常用于单向通信，即从服务器到客户端。
● SSE 使用标准的 HTTP 连接，但与常规 HTTP 连接不同的是，SSE 连接在数据发送后不会关闭，允许服务器持续推送消息。
● SSE 通常用于实现如股票行情更新、新闻订阅、社交媒体实时通知等功能。
2.WebSockets：
● WebSocket 提供了全双工通信通道，允许客户端和服务器之间进行双向通信。
● 与 SSE 不同，WebSocket 协议在建立连接时需要一个握手过程，之后通信双方可以自由地发送数据。
● WebSocket 适用于需要高度交互性的应用，如在线聊天、实时游戏、协作编辑等。

对于这四种即使通信协议，从性能的角度来看： WebSocket > 长连接（SEE） > 长轮询 > 短轮询 但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了： 短轮询 > 长轮询 > 长连接（SEE） > WebSocket 所以，还是要根据具体的使用场景来判断使用哪种方式


11.Fetch API 与传统 Request 的区别
https://juejin.cn/post/7378836196032610345

12. HTTP 如何实现长连接？在什么时候会超时？
HTTP/1.1 Keep-Alive、服务端推送、轮询访问

13.什么是 GraphQL？与传统的 REST API 相比，它提供了哪些优势？
GraphQL 是一个由 Facebook 开发的查询语言，用于 API，并且是一个运行时用来处理这些查询的服务器端系统。
1. 类型系统：
2. 精确性：
3. 减少数据传输：
4. 实时更新：
5. 错误处理：
6. 灵活性：
7. 缓存优化：
14.HTTP 和 HTTPS 的区别是什么？
1.安全性：
● HTTP：是明文传输的，不提供任何加密，数据在传输过程中可以被窃听或篡改。
● HTTPS：在 HTTP 的基础上通过 SSL/TLS 协议提供了加密，保护了数据传输过程中的安全性，防止数据被窃听或篡改。
2.端口：
● HTTP：默认使用 80 端口。
● HTTPS：默认使用 443 端口。
3.URL：
● HTTP：URL 以http://开头。
● HTTPS：URL 以https://开头。
4.搜索引擎优化（SEO）：
● 使用HTTPS的网站可能会获得搜索引擎的优先排名，因为搜索引擎倾向于推广安全的网站。
5.使用场景：
● HTTP适用于不需要安全加密的普通文本数据传输，如一些静态网页。
● HTTPS适用于需要保护用户隐私和数据安全的场合，如网上银行、在线支付、登录页面等
15. 什么是跨域问题，如何解决？（同源策略）
跨域问题，也称为**CORS（Cross-Origin Resource Sharing，跨源资源共享）**问题，是指当一个 Web 应用尝试访问与它不同源的资源时，出于安全考虑，浏览器会阻止这种访问。这里的“源”指的是协议、域名和端口的组合。
同源策略是浏览器的一个安全机制，它限制了来自不同源的文档或脚本对当前文档的读取或设置权限。这是为了防止恶意网站读取另一个网站的数据。

解决跨域问题的方法包括：
1. JSONP（JSON with Padding）：
● 利用<script>标签可以跨域加载资源的特性，通过添加一个查询参数并处理回调函数来实现跨域数据传输。
2. CORS：
● 服务器通过在响应头中设置Access-Control-Allow-Origin，明确允许某些外部域访问资源。
3. 代理服务器：
● 在客户端和目标服务器之间设置一个代理服务器，客户端的请求先发送到代理服务器，然后由代理服务器转发到目标服务器。代理服务器返回的数据再由代理服务器转发给客户端。
4. 服务端配置：
● 服务器端可以配置 CORS 相关的响应头，允许特定的源、方法（如 GET、POST）和头部。
5. PostMessage：
● postMessage是 HTML5 引入的一种在不同源间安全通信的方式。它可以用于在不同源的窗口、iframe 或者标签页之间发送消息。
6. WebSocket：
● 当两个页面的主域名相同时，可以使用document.domain将它们的源设置为相同的，从而绕过同源策略。
7. WebWorker：
● 利用window.name属性在不同页面间共享信息，因为window.name在不同页面加载时会保持不变。
8. WebAssembly：
● 在某些情况下，WebAssembly 可以用来绕过 JavaScript 的同源策略限制。

16. 什么是 CDN，它如何加速内容的分发？
CDN，即内容分发网络（Content Delivery Network），是一种分布式网络服务，旨在通过将内容缓存到离用户更近的地理位置来加速内容的分发和提高访问速度。以下是 CDN 加速内容分发的主要方式：
1. 分布式节点：
● CDN 在全球范围内部署了多个节点，这些节点存储了内容的副本。
2. 地理位置优化：
● 当用户请求内容时，CDN 会将请求路由到最近的节点，减少数据传输的延迟。
3. 缓存机制：
● CDN 节点会缓存静态内容，如图片、视频、CSS 和 JavaScript 文件，当请求到达时，直接从缓存中提供内容。
4. 负载均衡：
● CDN 可以智能地分配请求到多个节点，避免单个节点过载。
5. 高可用性：
● 多个节点的存在提高了服务的可用性，即使某个节点发生故障，请求也可以被重定向到其他节点。
6. 边缘计算：
● 在一些高级的 CDN 服务中，边缘计算允许在网络边缘执行计算任务，减少延迟。
17: 什么是 DNS 预解析，它对性能优化有何帮助？
DNS 预解析（也称为 DNS 预取或 DNS 预加载）是一种技术，它允许浏览器在实际需要之前就开始解析域名。这通常用于提高 Web 页面的加载时间，通过减少页面加载过程中的 DNS 查询延迟。

DNS 预解析的工作原理：
1. 预解析触发：
● 浏览器在解析 HTML 文档时遇到带有<link rel="prefetch">或<link rel="dns-prefetch">的标签时，会触发 DNS 预解析。
DNS 预解析对性能优化的帮助：
1. 减少延迟：
● 通过提前进行 DNS 查询，可以减少页面加载过程中的延迟，因为当实际请求资源时，DNS 查询已经完成。
2. 优化用户体验：
● 用户感受到的是页面加载更快，响应更迅速，从而提升整体的用户体验。
18.什么是 HTTP/2，它相比 HTTP/1.x 有哪些改进？
HTTP/2 是 HTTP 协议的第二个主要版本，旨在解决 HTTP/1.x 的一些性能限制，提供更快的网络通信。以下是 HTTP/2 相比 HTTP/1.x 的主要改进：

1. 二进制帧：
● HTTP/2 采用二进制格式传输数据，而不是 HTTP/1.x 的文本格式，这使得解析更高效，减少了潜在的错误。
2. 多路复用：
● HTTP/2 允许在单个 TCP 连接上并行传输多个请求和响应，解决了 HTTP/1.x 中的队头阻塞问题。
3. 头部压缩：
● HTTP/2 引入了 HPACK 压缩算法，对请求和响应的头部信息进行压缩，减少了冗余头部信息的传输。
4. 服务器推送：
● 服务器可以主动向客户端推送资源，而不需要客户端明确请求，这有助于提前加载资源。
5. 安全性：
● 虽然 HTTP/2 本身不加密，但它强制使用 TLS（传输层安全性协议），提高了数据传输的安全性。



http请求知识
1. GET和POST的请求的区别
Post 和 Get 是 HTTP 请求的两种方法，其区别如下：
● 应用场景： GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。
● 是否缓存： 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。
● 发送的报文格式： Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。
● 安全性： Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。
● 请求长度： 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。
● 参数类型： post 的参数传递支持更多的数据类型。
2. POST和PUT请求的区别
● PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时更新数据）
● POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是创建数据）
3. 常见的HTTP请求头和响应头
HTTP Request Header 常见的请求头：
Accept:浏览器能够处理的内容类型
Accept-Charset:浏览器能够显示的字符集
Accept-Encoding：浏览器能够处理的压缩编码
Accept-Language：浏览器当前设置的语言
Connection：浏览器与服务器之间连接的类型
Cookie：当前页面设置的任何Cookie
Host：发出请求的页面所在的域
Referer：发出请求的页面的URL
User-Agent：浏览器的用户代理字符串


HTTP Responses Header 常见的响应头：
Date：表示消息发送的时间，时间的描述格式由rfc822定义
server:服务器名称
Connection：浏览器与服务器之间连接的类型
Cache-Control：控制HTTP缓存
content-type:表示后面的文档属于什么MIME类型

4.常见的HTTP请求方法
GET: 向服务器获取数据；
POST：将实体提交到指定的资源，通常会造成服务器资源的修改；
PUT：上传文件，更新数据；
DELETE：删除服务器上的对象；
HEAD：获取报文首部，与GET相比，不返回报文主体部分；
OPTIONS：询问支持的请求方法，用来跨域请求；
CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；
TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。

5. OPTIONS请求方法及使用场景
OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。
OPTIONS方法是用于请求获得由Request-URI标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。该请求方法的响应不能缓存。
OPTIONS请求方法的主要用途有两个：
● 获取服务器支持的所有HTTP请求方法；
● 用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。

6.HTTP2的头部压缩算法是怎样的？


7. HTTP请求报文的是什么样的？


8. HTTP响应报文的是什么样的？

9. 与缓存相关的HTTP请求头有哪些
强缓存：
● Expires
● Cache-Control
协商缓存：
● Etag、If-None-Match
● Last-Modified、If-Modified-Since




一、浏览器加载页面的过程
1. 浏览器加载网页的全过程是什么？
  ○ 主要步骤包括：
    ⅰ. 地址解析：输入 URL 后，浏览器首先会进行 DNS 查询获取服务器 IP。
    ⅱ. 建立连接：建立 TCP 连接（包括三次握手），如果是 HTTPS，还会进行 TLS 握手。
    ⅲ. 发送请求与接收响应：浏览器发送 HTTP 请求，服务器返回响应数据。
    ⅳ. 资源加载：HTML、CSS、JS、图片等资源下载过程中可能会遵循并发连接数限制。
    ⅴ. 解析与构建 DOM 树：解析 HTML，构建 DOM 树；解析 CSS，构建 CSSOM 树。
    ⅵ. 生成渲染树：将 DOM 树与 CSSOM 树结合生成渲染树（Render Tree）。
    ⅶ. 布局（Layout/Reflow）：根据渲染树计算每个节点的准确位置和尺寸。
    ⅷ. 绘制（Paint/Repaint）：将各个元素绘制到屏幕上，后续可能进行图层合成。
    ⅸ. 合成（Composite）：如果存在 GPU 加速或分层绘制，则各层最终合成展示在屏幕上。
  ○ 这整个过程又被称为浏览器“关键渲染路径”。【blog.csdn.net】
参考答案扩展
（1）解析URL： 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。

（2）缓存判断： 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。

（3）DNS解析： 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。

（4）获取MAC地址： 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。

（5）TCP三次握手： 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。

（6）HTTPS握手： 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。

（7）返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。

（8）页面渲染： 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。

（9）TCP四次挥手： 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。

2. 什么是关键渲染路径（Critical Rendering Path），如何优化？
  ○ 关键渲染路径 指的是浏览器为将最初屏幕内容呈现出来所必须执行的所有步骤。
  ○ 优化方向包括：
    ■ 减少阻塞资源：将 CSS、JS 文件放在合适位置或采用异步、延迟加载；
    ■ 合并与压缩文件：减少 HTTP 请求数量和文件体积；
    ■ 利用缓存：充分利用浏览器缓存减少重复加载；
    ■ 关键内容优先加载：采用预加载、预渲染等技术使关键资源尽快可用。【blog.csdn.net】

二、重排与重绘
1. 什么是重排（reflow）与重绘（repaint）？它们有何区别？
  ○ 重排（回流）：当页面结构、几何属性（如尺寸、位置、字体大小）发生变化时，浏览器需要重新计算元素的几何信息，并更新布局。重排往往比重绘消耗资源更多。
  ○ 重绘（重构）：当元素的外观（比如颜色、背景）发生变化，但不影响尺寸和布局时，仅需要重新绘制该部分，不改变布局。
  ○ 触发情况：例如修改宽度、高度、文档流相关属性（会引发重排）；修改颜色、背景（通常只重绘）。【juejin.cn】
2. 哪些操作会触发浏览器重排与重绘？
  ○ 会导致重排的操作：
    ■ 添加、删除或更改 DOM 元素
    ■ 改变元素尺寸、边距、填充、边框或字体大小
    ■ DOM 节点移动或改变位置属性
  ○ 会导致重绘的操作：
    ■ 改变颜色、背景、visibility 等不影响布局的样式
  ○ 注意：某些操作既会引发重排，也会引发重绘，例如改变元素的 display 属性会使其从文档流消失，从而引发整体布局的重新计算。

三、浏览器性能和渲染优化
1. 浏览器加载性能优化有哪些措施？
  ○ 减少阻塞：将 CSS 保持在头部，以便尽快构建渲染树，而将 JS 脚本放在底部或使用 async/defer。
  ○ 资源压缩与合并：合并 CSS、JS 文件、压缩图片和代码，减少请求数。
  ○ 合理利用缓存：设置 HTTP 缓存策略、利用 Service Worker 缓存静态资源。
  ○ 预加载和懒加载：使用 <link rel="preload">、<link rel="prefetch"> 提前加载关键资源，非关键资源使用懒加载。
  ○ 优化关键渲染路径：尽量缩短渲染路径，减少页面初始加载阻塞。【blog.csdn.net】
2. 浏览器缓存机制及其在页面加载中的作用？
  ○ 浏览器有多种缓存策略：
    ■ HTTP 缓存：包括强缓存（Expires、Cache-Control）和协商缓存（Last-Modified、ETag）
    ■ DNS 缓存：减少域名解析次数
    ■ 内存和磁盘缓存：存储已加载的资源，减少重复请求
  ○ 利用缓存可以显著提升页面加载速度，降低服务器压力。
3. 浏览器事件循环（Event Loop）机制是什么？
  ○ 浏览器中的 JavaScript 引擎采用单线程，通过事件循环机制来处理任务队列，将异步任务分为宏任务和微任务，确保任务按照正确顺序执行。
  ○ 常见问题包括：宏任务（setTimeout、setInterval、I/O 等）与微任务（Promise.then、MutationObserver 等）的执行顺序差异。

四、其他浏览器原理知识
1. 浏览器工作原理相关知识点，还包括哪些？
  ○ DOM 与 CSSOM 构建：解析 HTML 和 CSS 生成 DOM 与 CSSOM。
  ○ 渲染引擎原理：不同浏览器内核（如 Blink、WebKit、Gecko）在解析、布局、绘制过程中的异同。
  ○ 合成层和 GPU 加速：了解哪些 CSS 属性会促使浏览器创建单独层（如 transform 和 opacity），从而利用硬件加速。
  ○ JS 内存管理与垃圾回收：了解标记清除、引用计数等原理以及内存泄漏防范。
  ○ 同源策略及跨域解决方案：了解浏览器同源策略的作用、局限以及 CORS、JSONP 等跨域技术。
2. 如何解释浏览器加载网页时的“关键渲染路径”以及各阶段所耗费的时间？
  ○ 关键渲染路径涉及从资源获取、解析 HTML/CSS、构建 DOM/CSSOM、生成渲染树、布局、绘制到合成的过程。
  ○ 每个阶段的耗时都可能成为性能瓶颈，因此常用工具（如 Chrome DevTools 的 Performance 面板）进行时间分析和优化。
3. 浏览器中“重绘”和“重排”对性能的影响及如何优化？
  ○ 重排（Reflow）是性能代价最高的操作，因为它会重新计算布局；重绘（Repaint）的开销较小。
  ○ 优化策略：尽量批量更改 DOM，减少对会引起重排的属性修改，使用 CSS3 的 transform 和 opacity 替代 top、left 等改变布局的属性；利用合成层提升局部动画性能。

